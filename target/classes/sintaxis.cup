package edu.mooncoder.model.analyzer.syntax;

import java.util.List;
import java.util.ArrayList;

import edu.mooncoder.model.analyzer.lexic.JavaLexer;

parser code {:
  public JavaParser(JavaLexer lexer) {
    super(lexer);
  }
:}

terminal PACKAGE, IMPORT, CLASS, VISIBILITY, FINAL;
terminal ID;
terminal PUNTO, SEPARADOR, LLA_IZQ, LLA_DER, VOID,
         TYPE, COMA, PAR_IZQ, PAR_DER, LOGIC, BREAK,
         IF, ELIF, ELSE, FOR, NEW, OBJECT, LITERAL, MAS,
         MENOS, DIV, POR, ENTERO, DECIMAL, RETURN, IGUAL,
         NEGADO;

non terminal syntax;
non terminal packag, imports, clase;
non terminal class_items, pack_item, attr_inv;
non terminal full_dec, var_dec, more_dec, assign, valor,
             func, string, numero, dec_func,
             dec_attr, instruct, body, for, bool,
             cic_inst, control, if, elif, else, for_dec,
             for_bool, expr, type;

precedence left MAS, MENOS;
precedence left POR, DIV;
precedence left NEGADO;

start with syntax;

syntax ::= packag imports clase;

packag   ::= PACKAGE ID pack_item SEPARADOR
             |
             PACKAGE ID SEPARADOR
             |
             ;

imports  ::= IMPORT ID pack_item SEPARADOR imports
             |
             IMPORT ID SEPARADOR imports
             |
             ;

clase     ::= VISIBILITY CLASS ID LLA_IZQ class_items LLA_DER
              |
              CLASS ID LLA_IZQ class_items LLA_DER
              ;

class_items ::= VISIBILITY FINAL full_dec class_items
                |
                VISIBILITY full_dec class_items
                |
                FINAL full_dec class_items
                |
                full_dec class_items
                |
                VISIBILITY dec_func class_items
                |
                dec_func class_items
                |
                ;

pack_item ::= PUNTO ID pack_item
              |
              PUNTO ID
              |
              PUNTO POR
              ;

dec_attr ::= type ID COMA dec_attr
             |
             type ID
             |
             ;

attr_inv ::= valor
             |
             attr_inv COMA valor
             ;

dec_func ::= type ID PAR_IZQ dec_attr PAR_DER LLA_IZQ body LLA_DER
             |
             VOID ID PAR_IZQ dec_attr PAR_DER LLA_IZQ body LLA_DER
             ;

instruct ::= full_dec
             |
             assign
             |
             func
             |
             RETURN SEPARADOR
             |
             RETURN valor SEPARADOR
             |
             if
             |
             for
             ;

body     ::= instruct body
             |
             ;

bool     ::= valor LOGIC valor;

cic_inst ::= instruct cic_inst
             |
             BREAK SEPARADOR cic_inst
             ;

control  ::= LLA_IZQ cic_inst LLA_DER
             |
             instruct
             ;
              
if       ::= IF PAR_IZQ bool PAR_DER LLA_IZQ body LLA_DER elif else
             ;

elif     ::= ELIF PAR_IZQ bool PAR_DER LLA_IZQ body LLA_DER elif
             |
             ;

else     ::= ELSE LLA_IZQ body LLA_DER
             |
             ;

for_dec  ::= type var_dec more_dec SEPARADOR
             |
             SEPARADOR
             ;

for_bool ::= bool SEPARADOR | SEPARADOR;

for      ::= FOR PAR_DER for_dec for_bool assign control;

func     ::= ID PAR_IZQ attr_inv PAR_DER SEPARADOR
             |
             ID PAR_IZQ PAR_DER SEPARADOR
             ;

full_dec ::= type var_dec more_dec SEPARADOR;

var_dec  ::= ID
             |
             assign
             ;

more_dec ::= COMA var_dec more_dec
             |
             ;

type     ::= TYPE | OBJECT;

assign   ::= ID IGUAL valor;

valor    ::= string
             |
             expr
             |
             NEW OBJECT PAR_IZQ PAR_DER
             ;

string   ::= LITERAL
             |
             string MAS LITERAL
             |
             string MAS numero
             |
             string MAS PAR_IZQ expr PAR_DER
             ;

expr     ::= expr MAS expr
             |
             expr POR expr
             |
             expr MENOS expr
             |
             expr DIV expr
             |
             PAR_IZQ expr PAR_DER
             |
             MENOS expr
             %prec NEGADO
             |
             numero
             ;

numero   ::= ID | ENTERO | DECIMAL;